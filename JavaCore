JavaCore
Java9

CHAPTER 1:

Static factory methods:
1.
In cases where a class seems to require
multiple constructors with the same signature, replace the constructors with static
factory methods and carefully chosen names to highlight their differences.
2.
A second advantage of static factory methods is that, unlike constructors,
they are not required to create a new object each time they’re invoked
This technique is similar to the
Flyweight pattern [Gamma95]. It can greatly improve performance if equivalent
objects are requested often, especially if they are expensive to create
3.
A third advantage of static factory methods is that, unlike constructors,
they can return an object of any subtype of their return type
4.
A fourth advantage of static factories is that the class of the returned
object can vary from call to call as a function of the input parameters.
. Any subtype of the declared return type is permissible. The class of the returned object can
also vary from release to release

A fifth advantage of static factories is that the class of the returned object
need not exist when the class containing the method is written. Such flexible
static factory methods form the basis of service provider frameworks, like the Java
Database Connectivity API (JDBC). A service provider framework is a system in
which providers implement a service, and the system makes the implementations
available to clients, decoupling the clients from the implementations??????????????????????????????????????????/

The main limitation of providing only static factory methods is that
classes without public or protected constructors cannot be subclassed.
============================
the Builder pattern is a good choice when designing classes
whose constructors or static factories would have more than a handful of
parameters
=============================
 Making a class a singleton can
make it difficult to test its clients because it’s impossible to substitute a mock
implementation for a singleton unless it implements an interface that serves as its
type.
a single-element
enum type is often the best way to implement a singleton. ???????????????????????explain


A default constructor is generated only if a class contains no explicit constructors, so a class can be
made noninstantiable by including a private constructor: and not by using abstract class.

Static utility classes and singletons are inappropriate for
classes whose behavior is parameterized by an underlying resource

Avoid using String and : prefer primitives to
boxed primitives, and watch out for unintentional autoboxing as Autobox creates unnessasary objects???????????

Nulling out object references should be the exception rather than the norm.
The best way to eliminate an obsolete reference is to let the variable that contained
the reference fall out of scope. This occurs naturally if you define each variable in
the narrowest possible scope
Eleminate obsolete ref with null****************

A third common source of memory leaks is listeners and other callbacks.
If you implement an API where clients register callbacks but don’t deregister them
explicitly, they will accumulate unless you take some action. One way to ensure
that callbacks are garbage collected promptly is to store only weak references to
them, for instance, by storing them only as keys in a WeakHashMap??????????? example??????


To protect nonfinal classes from finalizer attacks,
write a final finalize method that does nothing????????????????explain

Autoclosable???????????

Always use try-with-resources in preference to tryfinally when working with resources that must be closed???????????

==============================================================================================
==============================================================================================
CHAPTER  2:
CHAPTER  2:


Common methods in All Objects:
when not to override equals:
A superclass has already overridden equals, and the superclass behavior
is appropriate for this class
The class is private or package-private, and you are certain that its equals
method will never be invoked

One kind of value class that does not require the equals method to be overridden is a class that uses instance control (Item 1) to ensure that at most one object
exists with each value. Enum types (Item 34) fall into this category. For these
classes, logical equality is the same as object identity, so Object’s equals method
functions as a logical equals method

==============


Don’t substitute another type for Object in the equals declaration. It is not
uncommon for a programmer to write an equals method that looks like this
and then spend hours puzzling over why it doesn’t work properly:
// Broken - parameter type must be Object!
public boolean equals(MyClass o) {
...
}
The problem is that this method does not override Object.equals, whose
argument is of type Object, but overloads it instead

in practice, a class implementing
Cloneable is expected to provide a properly functioning public clone method.

Clone contrat:
the expression
x.clone() != x
will be true, and the expression
x.clone().getClass() == x.getClass()
will be true, but these are not absolute requirements. While it is typically the
case that
x.clone().equals(x)
will be true, this is not an absolute re

immutable classes should never provide a clone method??????????????????Clonable???????????

Clone vs copyconstructor vs factory copy??/

By implementing Comparable, a class indicates that its instances have a natural ordering

==============
For example, consider the BigDecimal class, whose compareTo method is
inconsistent with equals. If you create an empty HashSet instance and then add
new BigDecimal("1.0") and new BigDecimal("1.00"), the set will contain two
elements because the two BigDecimal instances added to the set are unequal
when compared using the equals method. If, however, you perform the same
procedure using a TreeSet instead of a HashSet, the set will contain only one
element because the two BigDecimal instances are equal when compared using
the compareTo method. (See the BigDecimal documentation for details.)*************************

java8 comparator constrction methods:
In Java 8, the Comparator interface was outfitted with a set of comparator
construction methods, which enable fluent construction of comparators. These
comparators can then be used to implement a compareTo method, as required by
the Comparable interface. Many programmers prefer the conciseness of this
approach, though it does come at a modest performance cost: sorting arrays of
PhoneNumber instances is about 10% slower on my machine. When using this
approach, consider using Java’s static import facility so you can refer to static
comparator construction methods by their simple names for clarity and brevity.
Here’s how the compareTo method for PhoneNumber looks using this approach:
// Comparable with comparator construction methods
private static final Comparator<PhoneNumber> COMPARATOR =
comparingInt((PhoneNumber pn) -> pn.areaCode)
.thenComparingInt(pn -> pn.prefix)
.thenComparingInt(pn -> pn.lineNum);
public int compareTo(PhoneNumber pn) {
return COMPARATOR.compare(this, pn);
}
***************************************************
comparator constrction methods example with java8 Streams*************




